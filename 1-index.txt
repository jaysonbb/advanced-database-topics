Indexes
	persistent data structure used to improve db performance
	stored on db
	
	table T
		a	b	c
	1	cat	2	
	2	dog	5
	3	cow	1
	4	cow 6
	
	index on t.a
		where t.a = 'cow'
			returns rows 2 and 4
	where statement w/ an index can retrieve rows w/out having to scan the entire table
	
	index on t.b 
		where t.b = 2
			returns row 1
		where t.b < 4
			returns rows 1, 3
			
	index on t.(a,b)
		combination of values
		t.a = whatever
		and t.b = something else
		
	index returns results from a table that match a condition w/out having to look at the entire table
	
	
	underlying data strcutures
		- balanced tres (b trees, b+ trees)
			used to help attribute = value
						 attribute < value
						 attirbute between val1 and val2
			log(n)
		- hash tables
			only used for equality: attribute = val
			constant time
	
	
	--------
	select name
	from students
	where name = 'jayson'
	
	index on o.name
	many db's build indexes automatically on primary keys (and sometimes unique values)
	
	-------
	select id
	from student
	where name = 'Mary' and GPA > 3.9
	
	index on name <- hashed or tree
	index on gpa  <- should be tree based
	index on (name, gpa)
	
	---------
	select student_name, college_name
	from student, apply
	where student.id = apply.student_id
	
	index on apply.student_id
	index on student.id
	

downside of indices
	1. extra space
	2. index creation overhead
		adding indexes later, adding w/ inserts & updates
	3. index maintenace
		data structure that helps answer conditions
		when values change, index must be adjusted
		cost of maintenance can offset benefits
	
	benefit of an index depends on
		1. size of table
		2. data distributions
		3. query vs update loads
		
	physical design advisors
		input: data in database (statistics) and workload
		output: recommended indexes
		
		query optimizer
			compononet that figures out how to execute query/update
			explores best execution plan given query and indices on db
			
		design advisor
			like query optimizer, but determines where the indices should be
			based on workload and costs of querying
			which indexes benefit queries the most given the index creation overhead
			
		
	syntax of index creation
	create index indexname on t(a)
	create index indexname on t(a1, a2,..,an)
	create unique index indexname on t(a) (make sure all vals are unique)
	drop index indexname